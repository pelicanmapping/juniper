/* -*-c++-*- */
/* osgJuniper - Large Dataset Visualization Toolkit for OpenSceneGraph
 * Copyright 2010-2011 Pelican Ventures, Inc.
 * http://wush.net/trac/juniper
 *
 * osgEarth is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 */

#ifndef QSPLAT_MODEL_H
#define QSPLAT_MODEL_H 1

#include <osgJuniper/PointCloud>
#include <osg/Referenced>
#include <osg/Node>


#ifdef WIN32
# define WIN32_LEAN_AND_MEAN
# include <windows.h>
# include <commctrl.h>
# define off_t int
#else
# define HANDLE int
# define HFILE int
#endif

struct ViewerInfo
{
    osg::Matrix _modelview;
    osg::Matrix _projection;
    int _width;
    int _height;

    float      _pixelsPerRadian;
    osg::Vec3  _cameraPosition;
    float      _frustum[4][4];
    osg::Plane _zproj;
    float _minsize;
    void compute(osg::CullStack* cs)
    {
        _modelview = *(cs->getModelViewMatrix());
        _projection = *(cs->getProjectionMatrix());
        _width = cs->getViewport()->width();
        _height = cs->getViewport()->height();

        osg::Matrix projectionModelView = _modelview * _projection;

        // Compute some stuff
        _cameraPosition[0] = -(_modelview.ptr()[0]*_modelview.ptr()[12] + _modelview.ptr()[1]*_modelview.ptr()[13] + _modelview.ptr()[2]*_modelview.ptr()[14]);
        _cameraPosition[1] = -(_modelview.ptr()[4]*_modelview.ptr()[12] + _modelview.ptr()[5]*_modelview.ptr()[13] + _modelview.ptr()[6]*_modelview.ptr()[14]);
        _cameraPosition[2] = -(_modelview.ptr()[8]*_modelview.ptr()[12] + _modelview.ptr()[9]*_modelview.ptr()[13] + _modelview.ptr()[10]*_modelview.ptr()[14]);

        _pixelsPerRadian = 0.5f * _width * _projection.ptr()[0]; // Assume glFrustum only

        _zproj[0] = -_modelview.ptr()[2];
        _zproj[1] = -_modelview.ptr()[6];
        _zproj[2] = -_modelview.ptr()[10];
        _zproj[3] = -_modelview.ptr()[14];

        _frustum[0][0] = projectionModelView.ptr()[3]  - projectionModelView.ptr()[1];
        _frustum[0][1] = projectionModelView.ptr()[7]  - projectionModelView.ptr()[5];
        _frustum[0][2] = projectionModelView.ptr()[11] - projectionModelView.ptr()[9];
        _frustum[0][3] = projectionModelView.ptr()[15] - projectionModelView.ptr()[13];
        float tmp = 1.0f / Len(&_frustum[0][0]);
        _frustum[0][0] *= tmp;
        _frustum[0][1] *= tmp;
        _frustum[0][2] *= tmp;
        _frustum[0][3] *= tmp;
        _frustum[1][0] = projectionModelView.ptr()[3]  + projectionModelView.ptr()[1];
        _frustum[1][1] = projectionModelView.ptr()[7]  + projectionModelView.ptr()[5];
        _frustum[1][2] = projectionModelView.ptr()[11] + projectionModelView.ptr()[9];
        _frustum[1][3] = projectionModelView.ptr()[15] + projectionModelView.ptr()[13];
        tmp = 1.0f / Len(&_frustum[1][0]);
        _frustum[1][0] *= tmp;
        _frustum[1][1] *= tmp;
        _frustum[1][2] *= tmp;
        _frustum[1][3] *= tmp;
        _frustum[2][0] = projectionModelView.ptr()[3]  - projectionModelView.ptr()[0];
        _frustum[2][1] = projectionModelView.ptr()[7]  - projectionModelView.ptr()[4];
        _frustum[2][2] = projectionModelView.ptr()[11] - projectionModelView.ptr()[8];
        _frustum[2][3] = projectionModelView.ptr()[15] - projectionModelView.ptr()[12];
        tmp = 1.0f / Len(&_frustum[2][0]);
        _frustum[2][0] *= tmp;
        _frustum[2][1] *= tmp;
        _frustum[2][2] *= tmp;
        _frustum[2][3] *= tmp;
        _frustum[3][0] = projectionModelView.ptr()[3]  + projectionModelView.ptr()[0];
        _frustum[3][1] = projectionModelView.ptr()[7]  + projectionModelView.ptr()[4];
        _frustum[3][2] = projectionModelView.ptr()[11] + projectionModelView.ptr()[8];
        _frustum[3][3] = projectionModelView.ptr()[15] + projectionModelView.ptr()[12];
        tmp = 1.0f / Len(&_frustum[3][0]);
        _frustum[3][0] *= tmp;
        _frustum[3][1] *= tmp;
        _frustum[3][2] *= tmp;
        _frustum[3][3] *= tmp;
    }
};


class GeometryGraph : public osg::Group
{
public:

    void setupGeometry();
    osg::ref_ptr<osg::Geometry> _geometry;
    osg::ref_ptr<osg::Material> _material;
    osg::ref_ptr<osg::Vec3Array> _vertexes;
    osg::ref_ptr<osg::Vec3Array> _normals;
    osg::ref_ptr<osg::Vec4Array> _attributes;
    osg::ref_ptr<osg::Vec4Array> _colors;
    osg::ref_ptr<osg::DrawArrays> _drawarray;
    osg::ref_ptr<osg::StateSet> _stateset;

    float _minsize;
    int _attributeBinding;

    virtual void createSceneGraph() = 0;
    virtual void addPoint(float zFromCamera, float cx, float cy, float cz,
                          float r, float splatsize,
                          const float *norm, const float *col);

    virtual void update(const ViewerInfo& vi);

    virtual void reset() {
        if (!_vertexes.valid())
            createSceneGraph();
        _vertexes->clear();
        _normals->clear();
        _colors->clear();
        _attributes->clear();
    }
    virtual void dirty() {
        _vertexes->dirty();
        _normals->dirty();
        _colors->dirty();
        _attributes->dirty();
        _drawarray->setCount(_vertexes->size());
        _geometry->dirtyBound();
        computeBound();
    }
};


class GeometryGraphBasic : public GeometryGraph
{
public:

    virtual void createSceneGraph();
};

class GeometryGraphAdvanced : public GeometryGraph
{
public:

    struct SplatVertex {
        osg::Vec3 _vertex;
        const float* _normal;
        const float* _color;
        float _radius;
        float _depth;

        SplatVertex() {}
        SplatVertex(const osg::Vec3& vertex, const float* normal, const float* color, float size, float depthFromCamera) : _vertex(vertex), _normal(normal), _color(color), _radius(size), _depth(depthFromCamera) {}
    };

    struct BackToFrontSortFunctor
    {
        bool operator() (const SplatVertex& lhs,const SplatVertex& rhs) const
        {
            return (rhs._depth < lhs._depth);
        }
    };

    typedef std::set<SplatVertex, BackToFrontSortFunctor> SortContainer;
    SortContainer _sortBuffer;

    virtual void createSceneGraph();
    void update(const ViewerInfo& vi);
};

class GeometryGraphDeferredShading : public GeometryGraph
{
public:

    virtual void createSceneGraph();
    void update(const ViewerInfo& vi);

    int _texWidth;
    int _texHeight;
};


class QSplatModel : public osg::Operation
{

public:

    GeometryGraph* createNewGeometry();
    void setGeometry(GeometryGraph* geom);
    GeometryGraph* getGeometry() { return _geometryGraph.get(); }
    void operator()(osg::Object*);

    enum GeometryGraphType {
        BASIC,
        ADVANCED,
        DEFERRED
    };
    
    void setQuality(GeometryGraphType type) { _rendering = type; }



    void setupBuild(const ViewerInfo& vi, float minsize, bool frustrumCulling, bool backfaceCulling);
    bool build(bool frustrumCulling, bool backfaceCulling);

    // Try to open a file.  Returns a new QSplat_Model, or NULL if can't open it.
    static QSplatModel *Open(const char *modelfilename);

    QSplatModel(const std::string &filename_,
                unsigned char *mem_start_,
                unsigned char *map_start_,
                HANDLE fd_,
                off_t len_) : osg::Operation("QSplatModel", false),
        _filename(filename_), _leaf_points(0),
        _mem_start(mem_start_), _map_start(map_start_),
        _fd(fd_), _len(len_), _checkCounter(0), _pointSizeThreshold(10)
    {
        Init();
        _frustumCulling = true;
        _backfaceCulling = false;
        _overallSplatSize = true;
    }

    void initModel();


// Destructor - unmap the file
    ~QSplatModel();


// Initialize global data structures for QSplat
    static void Init();
    

// Determine length of an open file
    static off_t FileLen(HFILE fd);


// Memory map a file, returning pointers to the start of the allocated
// memory region and the start of the map
// This returns true if we were able to do the mmap
    static bool MapFile(HANDLE fd, off_t len,
                 unsigned char **mem_start,
                 unsigned char **map_start);


    inline void drawpoint(float zFromCamera, float cx, float cy, float cz,
                          float r, float splatsize,
                          const float *norm, const float *col) { _geometryGraph->addPoint(zFromCamera, cx, cy, cz, r, splatsize, norm, col); }

    void draw_hierarchy_leaves(const unsigned char *here, int numnodes,
                               float cx, float cy, float cz, float r,
                               float approx_splatsize_scale);
    void draw_hierarchy_fast(const unsigned char *here, int numnodes,
                             float cx, float cy, float cz, float r);

    void draw_hierarchy(const unsigned char *here, int numnodes,
                        float cx, float cy, float cz, float r,
                        bool backfacecull, bool frustumcull);


    bool getSelectByDistFromCamera() { return _overallSplatSize; }
    void setSelectByDistFromCamera(bool yesno) { _overallSplatSize = yesno; }

    const std::string& getFilename() const { return _filename; }

protected:

    std::string _filename;

    // Total number of points at the leaf nodes
    int _leaf_points;

    unsigned char *_mem_start;
    unsigned char *_map_start;
    HANDLE _fd;
    off_t _len;

// A single file can have multiple fragments - the file just looks like
// the files for the individual fragments catted together
    std::vector<const unsigned char *> _fragments;
    bool BuildFragmentList(const char *filename);

    std::string _comments;

    // Center and radius of all the fragments together
    osg::Vec3 _center;
    float _radius;
    
    bool _overallSplatSize;

    bool _haveColor;

    bool _bail;
    unsigned int _checkCounter;
    ViewerInfo _viewInfo;

    unsigned int _pointSizeThreshold;

    int _nodeSize;

    bool _frustumCulling;
    bool _backfaceCulling;

    OpenThreads::Mutex _mutex;
    
    GeometryGraphType _rendering;
    osg::ref_ptr<GeometryGraph> _geometryGraph;
};

#endif
