/* -*-c++-*- */
/* osgJuniper - Large Dataset Visualization Toolkit for OpenSceneGraph
* Copyright 2010-2017 Pelican Mapping
* Pelican Mapping CONFIDENTIAL
* Copyright (c) 2010-2017 [Pelican Mapping], All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains the property of Pelican Mapping. The intellectual and technical concepts contained
* herein are proprietary to Pelican Mapping and may be covered by U.S. and Foreign Patents, patents in process, and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material is strictly forbidden unless prior written permission is obtained
* from Pelican Mapping.  Access to the source code contained herein is hereby forbidden to anyone except current Pelican Mapping employees, managers or contractors who have executed
* Confidentiality and Non-disclosure agreements explicitly covering such access.
*
* The copyright notice above does not evidence any actual or intended publication or disclosure  of  this source code, which includes
* information that is confidential and/or proprietary, and is a trade secret, of Pelican Mapping.   ANY REPRODUCTION, MODIFICATION, DISTRIBUTION, PUBLIC  PERFORMANCE,
* OR PUBLIC DISPLAY OF OR THROUGH USE  OF THIS  SOURCE CODE  WITHOUT  THE EXPRESS WRITTEN CONSENT OF PELICAN MAPPING IS STRICTLY PROHIBITED, AND IN VIOLATION OF APPLICABLE
* LAWS AND INTERNATIONAL TREATIES.  THE RECEIPT OR POSSESSION OF  THIS SOURCE CODE AND/OR RELATED INFORMATION DOES NOT CONVEY OR IMPLY ANY RIGHTS
* TO REPRODUCE, DISCLOSE OR DISTRIBUTE ITS CONTENTS, OR TO MANUFACTURE, USE, OR SELL ANYTHING THAT IT  MAY DESCRIBE, IN WHOLE OR IN PART.
*/
#ifndef OSGJUNIPER_KDTREE
#define OSGJUNIPER_KDTREE 1

#include "Common"
#include <osg/Shape>
#include <osg/Geometry>
#include <map>

namespace osgJuniper
{
    class OSGJUNIPER_EXPORT KdTree : public osg::Shape 
    {
    public:
        KdTree();
        KdTree(const KdTree& rhs, const osg::CopyOp& copyop=osg::CopyOp::SHALLOW_COPY);
        META_Shape(osg, KdTree)

        struct OSGJUNIPER_EXPORT BuildOptions
        {
            BuildOptions();

            unsigned int _numVerticesProcessed;
            unsigned int _targetNumVertsPerLeaf;
            unsigned int _maxNumLevels;
        };

        /** Build the kdtree from the specified source geometry object.
        * retun true on success. */ 
        virtual bool build(BuildOptions& buildOptions, osg::Geometry* geometry);

        typedef int value_type;

        /**
         * A node in the KdTree.
         *
         * If this is a non-leaf node, first>0 and second>0, and first and second are the
         *    indices of the left and right children of this node.
         *
         * If this is a leaf node, first<0, -first is the index of the first vertex in the node,
         *    and second is the number of vertices in the node.
         */
        struct OSGJUNIPER_EXPORT KdNode
        {
            KdNode() : first(0), second(0) {}
            KdNode(value_type f, value_type s) : first(f), second(s) {}

            osg::BoundingBox bb;
            value_type first;    
            value_type second;
        };

        typedef std::vector< KdNode > KdNodeList;

        int addNode(const KdNode& node)
        {
            int num = static_cast<int>(_kdNodes.size()); 
            _kdNodes.push_back(node); 
            return num;
        }

        KdNode& getNode(int nodeNum) { return _kdNodes[nodeNum]; }
        const KdNode& getNode(int nodeNum) const { return _kdNodes[nodeNum]; }

        KdNodeList& getNodes() { return _kdNodes; }
        const KdNodeList& getNodes() const { return _kdNodes; }

        void setVertices(osg::Vec3Array* vertices) { _vertices = vertices; }
        const osg::Vec3Array* getVertices() const { return _vertices.get(); }

    protected:

        osg::ref_ptr<osg::Vec3Array> _vertices;
        KdNodeList _kdNodes;

    };

    class OSGJUNIPER_EXPORT KdTreeBuilder : public osg::NodeVisitor
    {
    public:

        KdTreeBuilder();

        KdTreeBuilder(const KdTreeBuilder& rhs);

        META_NodeVisitor("osgJuniper","KdTreeBuilder")

        virtual KdTreeBuilder* clone() { return new KdTreeBuilder(*this); }

        void apply(osg::Geode& geode);

        KdTree::BuildOptions _buildOptions;

        osg::ref_ptr<KdTree> _kdTreePrototype;



    protected:

        virtual ~KdTreeBuilder() {}

    };
} // namespace osgJuniper

#endif // OSGJUNIPER_KTREE


