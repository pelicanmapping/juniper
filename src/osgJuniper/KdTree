/* -*-c++-*- */
/* osgJuniper - Large Dataset Visualization Toolkit for OpenSceneGraph
* Copyright 2010-2011 Pelican Ventures, Inc.
* http://wush.net/trac/juniper
*
* osgEarth is free software; you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>
*/
#ifndef OSGJUNIPER_KDTREE
#define OSGJUNIPER_KDTREE 1

#include "Common"
#include <osg/Shape>
#include <osg/Geometry>
#include <map>

namespace osgJuniper
{
    class OSGJUNIPER_EXPORT KdTree : public osg::Shape 
    {
    public:
        KdTree();
        KdTree(const KdTree& rhs, const osg::CopyOp& copyop=osg::CopyOp::SHALLOW_COPY);
        META_Shape(osg, KdTree)

        struct OSGJUNIPER_EXPORT BuildOptions
        {
            BuildOptions();

            unsigned int _numVerticesProcessed;
            unsigned int _targetNumVertsPerLeaf;
            unsigned int _maxNumLevels;
        };

        /** Build the kdtree from the specified source geometry object.
        * retun true on success. */ 
        virtual bool build(BuildOptions& buildOptions, osg::Geometry* geometry);

        typedef int value_type;

        /**
         * A node in the KdTree.
         *
         * If this is a non-leaf node, first>0 and second>0, and first and second are the
         *    indices of the left and right children of this node.
         *
         * If this is a leaf node, first<0, -first is the index of the first vertex in the node,
         *    and second is the number of vertices in the node.
         */
        struct OSGJUNIPER_EXPORT KdNode
        {
            KdNode() : first(0), second(0) {}
            KdNode(value_type f, value_type s) : first(f), second(s) {}

            osg::BoundingBox bb;
            value_type first;    
            value_type second;
        };

        typedef std::vector< KdNode > KdNodeList;

        int addNode(const KdNode& node)
        {
            int num = static_cast<int>(_kdNodes.size()); 
            _kdNodes.push_back(node); 
            return num;
        }

        KdNode& getNode(int nodeNum) { return _kdNodes[nodeNum]; }
        const KdNode& getNode(int nodeNum) const { return _kdNodes[nodeNum]; }

        KdNodeList& getNodes() { return _kdNodes; }
        const KdNodeList& getNodes() const { return _kdNodes; }

        void setVertices(osg::Vec3Array* vertices) { _vertices = vertices; }
        const osg::Vec3Array* getVertices() const { return _vertices.get(); }

    protected:

        osg::ref_ptr<osg::Vec3Array> _vertices;
        KdNodeList _kdNodes;

    };

    class OSGJUNIPER_EXPORT KdTreeBuilder : public osg::NodeVisitor
    {
    public:

        KdTreeBuilder();

        KdTreeBuilder(const KdTreeBuilder& rhs);

        META_NodeVisitor("osgJuniper","KdTreeBuilder")

        virtual KdTreeBuilder* clone() { return new KdTreeBuilder(*this); }

        void apply(osg::Geode& geode);

        KdTree::BuildOptions _buildOptions;

        osg::ref_ptr<KdTree> _kdTreePrototype;



    protected:

        virtual ~KdTreeBuilder() {}

    };
} // namespace osgJuniper

#endif // OSGJUNIPER_KTREE


