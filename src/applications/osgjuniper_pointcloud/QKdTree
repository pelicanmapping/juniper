/* -*-c++-*- */
/* osgJuniper - Large Dataset Visualization Toolkit for OpenSceneGraph
* Copyright 2010-2011 Pelican Ventures, Inc.
* http://wush.net/trac/juniper
*
* osgEarth is free software; you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>
*/
#ifndef OSGJUNIPER_QKDTREE
#define OSGJUNIPER_QKDTREE 1

#include <osgJuniper/Common>
#include <osg/Shape>
#include <osg/Geometry>
#include <osg/Material>
#include <osg/CullStack>
#include <map>


class QKdTree : public osg::Shape 
{
public:
    QKdTree();
    QKdTree(const QKdTree& rhs, const osg::CopyOp& copyop=osg::CopyOp::SHALLOW_COPY);
    META_Shape(osgJuniperPlugin, QKdTree)

    struct BuildOptions
    {
        BuildOptions() : _numVerticesProcessed(0),
            _targetNumVertsPerLeaf(32),
            _maxNumLevels(64)
            {}

        unsigned int _numVerticesProcessed;
        unsigned int _targetNumVertsPerLeaf;
        unsigned int _maxNumLevels;
    };

    /** Build the kdtree from the specified source geometry object.
     * retun true on success. */ 
    virtual bool build(BuildOptions& buildOptions, osg::Geometry* geometry);

    typedef int value_type;

    /**
     * A node in the KdTree.
     *
     * If this is a non-leaf node, first>0 and second>0, and first and second are the
     *    indices of the left and right children of this node.
     *
     * If this is a leaf node, first<0, -first is the index of the first vertex in the node,
     *    and second is the number of vertices in the node.
     */
    struct KdNode
    {
        KdNode() : first(0), second(0) {}
        KdNode(value_type f, value_type s, value_type index = -1) : first(f), second(s) {}

        osg::BoundingBox bb;
        value_type first;
        value_type second;
    };

    typedef std::vector< KdNode > KdNodeList;

    int addNode(const KdNode& node)
    {
        int num = static_cast<int>(_kdNodes.size()); 
        _kdNodes.push_back(node); 
        return num;
    }

    KdNode& getNode(int nodeNum) { return _kdNodes[nodeNum]; }
    const KdNode& getNode(int nodeNum) const { return _kdNodes[nodeNum]; }

    KdNodeList& getNodes() { return _kdNodes; }
    const KdNodeList& getNodes() const { return _kdNodes; }

    void setVertices(osg::Vec3Array* vertices) { _vertices = vertices; }
    const osg::Vec3Array* getVertices() const { return _vertices.get(); }

    void setNormals(osg::Vec3Array* normals) { _normals = normals; }
    const osg::Vec3Array* getNormals() const { return _normals.get(); }

    void setColors(osg::Vec4Array* colors) { _colors = colors; }
    const osg::Vec4Array* getColors() const { return _colors.get(); }

    void setSize(osg::Vec4Array* size) { _size = size; }
    const osg::Vec4Array* getSize() const { return _size.get(); }

protected:

    osg::ref_ptr<osg::Vec3Array> _vertices;
    osg::ref_ptr<osg::Vec3Array> _normals;
    osg::ref_ptr<osg::Vec4Array> _colors;
    osg::ref_ptr<osg::Vec4Array> _size;
    KdNodeList _kdNodes;

};

class KdTreeBuilder : public osg::NodeVisitor
{
public:

    KdTreeBuilder();

    KdTreeBuilder(const KdTreeBuilder& rhs);

    META_NodeVisitor("osgJuniper","KdTreeBuilder")

    virtual KdTreeBuilder* clone() { return new KdTreeBuilder(*this); }

    void apply(osg::Geode& geode);

    QKdTree::BuildOptions _buildOptions;

    osg::ref_ptr<QKdTree> _kdTreePrototype;



protected:

    virtual ~KdTreeBuilder() {}

};

#endif // OSGJUNIPER_KTREE


