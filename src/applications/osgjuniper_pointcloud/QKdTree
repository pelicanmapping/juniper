/* -*-c++-*- */
/* osgJuniper - Large Dataset Visualization Toolkit for OpenSceneGraph
* Copyright 2010-2017 Pelican Mapping
* Pelican Mapping CONFIDENTIAL
* Copyright (c) 2010-2017 [Pelican Mapping], All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains the property of Pelican Mapping. The intellectual and technical concepts contained
* herein are proprietary to Pelican Mapping and may be covered by U.S. and Foreign Patents, patents in process, and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material is strictly forbidden unless prior written permission is obtained
* from Pelican Mapping.  Access to the source code contained herein is hereby forbidden to anyone except current Pelican Mapping employees, managers or contractors who have executed
* Confidentiality and Non-disclosure agreements explicitly covering such access.
*
* The copyright notice above does not evidence any actual or intended publication or disclosure  of  this source code, which includes
* information that is confidential and/or proprietary, and is a trade secret, of Pelican Mapping.   ANY REPRODUCTION, MODIFICATION, DISTRIBUTION, PUBLIC  PERFORMANCE,
* OR PUBLIC DISPLAY OF OR THROUGH USE  OF THIS  SOURCE CODE  WITHOUT  THE EXPRESS WRITTEN CONSENT OF PELICAN MAPPING IS STRICTLY PROHIBITED, AND IN VIOLATION OF APPLICABLE
* LAWS AND INTERNATIONAL TREATIES.  THE RECEIPT OR POSSESSION OF  THIS SOURCE CODE AND/OR RELATED INFORMATION DOES NOT CONVEY OR IMPLY ANY RIGHTS
* TO REPRODUCE, DISCLOSE OR DISTRIBUTE ITS CONTENTS, OR TO MANUFACTURE, USE, OR SELL ANYTHING THAT IT  MAY DESCRIBE, IN WHOLE OR IN PART.
*/
#ifndef OSGJUNIPER_QKDTREE
#define OSGJUNIPER_QKDTREE 1

#include <osgJuniper/Common>
#include <osg/Shape>
#include <osg/Geometry>
#include <osg/Material>
#include <osg/CullStack>
#include <map>


class QKdTree : public osg::Shape
{
public:
    QKdTree();
    QKdTree(const QKdTree& rhs, const osg::CopyOp& copyop=osg::CopyOp::SHALLOW_COPY);
    META_Shape(osgJuniperPlugin, QKdTree)

    struct BuildOptions
    {
        BuildOptions() : _numVerticesProcessed(0),
            _targetNumVertsPerLeaf(32),
            _maxNumLevels(64)
            {}

        unsigned int _numVerticesProcessed;
        unsigned int _targetNumVertsPerLeaf;
        unsigned int _maxNumLevels;
    };

    /** Build the kdtree from the specified source geometry object.
     * retun true on success. */
    virtual bool build(BuildOptions& buildOptions, osg::Geometry* geometry);

    typedef int value_type;

    /**
     * A node in the KdTree.
     *
     * If this is a non-leaf node, first>0 and second>0, and first and second are the
     *    indices of the left and right children of this node.
     *
     * If this is a leaf node, first<0, -first is the index of the first vertex in the node,
     *    and second is the number of vertices in the node.
     */
    struct KdNode
    {
        KdNode() : first(0), second(0) {}
        KdNode(value_type f, value_type s, value_type index = -1) : first(f), second(s) {}

        osg::BoundingBox bb;
        value_type first;
        value_type second;
    };

    typedef std::vector< KdNode > KdNodeList;

    int addNode(const KdNode& node)
    {
        int num = static_cast<int>(_kdNodes.size());
        _kdNodes.push_back(node);
        return num;
    }

    KdNode& getNode(int nodeNum) { return _kdNodes[nodeNum]; }
    const KdNode& getNode(int nodeNum) const { return _kdNodes[nodeNum]; }

    KdNodeList& getNodes() { return _kdNodes; }
    const KdNodeList& getNodes() const { return _kdNodes; }

    void setVertices(osg::Vec3Array* vertices) { _vertices = vertices; }
    const osg::Vec3Array* getVertices() const { return _vertices.get(); }

    void setNormals(osg::Vec3Array* normals) { _normals = normals; }
    const osg::Vec3Array* getNormals() const { return _normals.get(); }

    void setColors(osg::Vec4Array* colors) { _colors = colors; }
    const osg::Vec4Array* getColors() const { return _colors.get(); }

    void setSize(osg::Vec4Array* size) { _size = size; }
    const osg::Vec4Array* getSize() const { return _size.get(); }

protected:

    osg::ref_ptr<osg::Vec3Array> _vertices;
    osg::ref_ptr<osg::Vec3Array> _normals;
    osg::ref_ptr<osg::Vec4Array> _colors;
    osg::ref_ptr<osg::Vec4Array> _size;
    KdNodeList _kdNodes;

};

class KdTreeBuilder : public osg::NodeVisitor
{
public:

    KdTreeBuilder();

    KdTreeBuilder(const KdTreeBuilder& rhs);

    META_NodeVisitor("osgJuniper","KdTreeBuilder")

    virtual KdTreeBuilder* clone() { return new KdTreeBuilder(*this); }

    void apply(osg::Geode& geode);

    QKdTree::BuildOptions _buildOptions;

    osg::ref_ptr<QKdTree> _kdTreePrototype;



protected:

    virtual ~KdTreeBuilder() {}

};

#endif // OSGJUNIPER_KTREE


